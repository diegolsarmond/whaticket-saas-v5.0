{"ast":null,"code":"import * as e from \"react\";\nfunction n() {\n  return n = Object.assign ? Object.assign.bind() : function (e) {\n    for (var n = 1; n < arguments.length; n++) {\n      var t = arguments[n];\n      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);\n    }\n    return e;\n  }, n.apply(this, arguments);\n}\nconst t = [\"children\", \"options\"];\nvar r, i;\n!function (e) {\n  e.blockQuote = \"0\", e.breakLine = \"1\", e.breakThematic = \"2\", e.codeBlock = \"3\", e.codeFenced = \"4\", e.codeInline = \"5\", e.footnote = \"6\", e.footnoteReference = \"7\", e.gfmTask = \"8\", e.heading = \"9\", e.headingSetext = \"10\", e.htmlBlock = \"11\", e.htmlComment = \"12\", e.htmlSelfClosing = \"13\", e.image = \"14\", e.link = \"15\", e.linkAngleBraceStyleDetector = \"16\", e.linkBareUrlDetector = \"17\", e.linkMailtoDetector = \"18\", e.newlineCoalescer = \"19\", e.orderedList = \"20\", e.paragraph = \"21\", e.ref = \"22\", e.refImage = \"23\", e.refLink = \"24\", e.table = \"25\", e.tableSeparator = \"26\", e.text = \"27\", e.textBolded = \"28\", e.textEmphasized = \"29\", e.textEscaped = \"30\", e.textMarked = \"31\", e.textStrikethroughed = \"32\", e.unorderedList = \"33\";\n}(r || (r = {})), function (e) {\n  e[e.MAX = 0] = \"MAX\", e[e.HIGH = 1] = \"HIGH\", e[e.MED = 2] = \"MED\", e[e.LOW = 3] = \"LOW\", e[e.MIN = 4] = \"MIN\";\n}(i || (i = {}));\nconst l = [\"allowFullScreen\", \"allowTransparency\", \"autoComplete\", \"autoFocus\", \"autoPlay\", \"cellPadding\", \"cellSpacing\", \"charSet\", \"className\", \"classId\", \"colSpan\", \"contentEditable\", \"contextMenu\", \"crossOrigin\", \"encType\", \"formAction\", \"formEncType\", \"formMethod\", \"formNoValidate\", \"formTarget\", \"frameBorder\", \"hrefLang\", \"inputMode\", \"keyParams\", \"keyType\", \"marginHeight\", \"marginWidth\", \"maxLength\", \"mediaGroup\", \"minLength\", \"noValidate\", \"radioGroup\", \"readOnly\", \"rowSpan\", \"spellCheck\", \"srcDoc\", \"srcLang\", \"srcSet\", \"tabIndex\", \"useMap\"].reduce((e, n) => (e[n.toLowerCase()] = n, e), {\n    for: \"htmlFor\"\n  }),\n  o = {\n    amp: \"&\",\n    apos: \"'\",\n    gt: \">\",\n    lt: \"<\",\n    nbsp: \" \",\n    quot: \"“\"\n  },\n  c = [\"style\", \"script\"],\n  a = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi,\n  s = /mailto:/i,\n  d = /\\n{2,}$/,\n  u = /^(\\s*>[\\s\\S]*?)(?=\\n{2,})/,\n  p = /^ *> ?/gm,\n  f = /^ {2,}\\n/,\n  h = /^(?:( *[-*_])){3,} *(?:\\n *)+\\n/,\n  m = /^\\s*(`{3,}|~{3,}) *(\\S+)?([^\\n]*?)?\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)*\\n?/,\n  g = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/,\n  y = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  k = /^(?:\\n *)*\\n/,\n  x = /\\r\\n?/g,\n  v = /^\\[\\^([^\\]]+)](:(.*)((\\n+ {4,}.*)|(\\n(?!\\[\\^).+))*)/,\n  b = /^\\[\\^([^\\]]+)]/,\n  $ = /\\f/g,\n  E = /^---[ \\t]*\\n(.|\\n)*\\n---[ \\t]*\\n/,\n  w = /^\\s*?\\[(x|\\s)\\]/,\n  S = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/,\n  C = /^ *(#{1,6}) +([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/,\n  A = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/,\n  O = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1\\b)[\\s\\S])*?)<\\/\\1>(?!<\\/\\1>)\\n*/i,\n  T = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi,\n  L = /^<!--[\\s\\S]*?(?:-->)/,\n  R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/,\n  z = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i,\n  M = /^\\{.*\\}$/,\n  I = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  U = /^<([^ >]+@[^ >]+)>/,\n  j = /^<([^ >]+:\\/[^ >]+)>/,\n  B = /-([a-z])?/gi,\n  N = /^(.*\\|.*)\\n(?: *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*))?\\n?/,\n  H = /^\\[([^\\]]*)\\]:\\s+<?([^\\s>]+)>?\\s*(\"([^\"]*)\")?/,\n  D = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n  P = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n  _ = /(\\[|\\])/g,\n  F = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/,\n  W = /\\t/g,\n  G = /(^ *\\||\\| *$)/g,\n  Z = /^ *:-+: *$/,\n  q = /^ *:-+ *$/,\n  V = /^ *-+: *$/,\n  X = \"((?:\\\\[.*?\\\\][([].*?[)\\\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~~.*?~~|==.*?==|.|\\\\n)*?)\",\n  Q = new RegExp(`^([*_])\\\\1${X}\\\\1\\\\1(?!\\\\1)`),\n  J = new RegExp(`^([*_])${X}\\\\1(?!\\\\1|\\\\w)`),\n  K = new RegExp(`^==${X}==`),\n  Y = new RegExp(`^~~${X}~~`),\n  ee = /^\\\\([^0-9A-Za-z\\s])/,\n  ne = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&#;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i,\n  te = /^\\n+/,\n  re = /^([ \\t]*)/,\n  ie = /\\\\([^\\\\])/g,\n  le = / *\\n+$/,\n  oe = /(?:^|\\n)( *)$/,\n  ce = \"(?:\\\\d+\\\\.)\",\n  ae = \"(?:[*+-])\";\nfunction se(e) {\n  return \"( *)(\" + (1 === e ? ce : ae) + \") +\";\n}\nconst de = se(1),\n  ue = se(2);\nfunction pe(e) {\n  return new RegExp(\"^\" + (1 === e ? de : ue));\n}\nconst fe = pe(1),\n  he = pe(2);\nfunction me(e) {\n  return new RegExp(\"^\" + (1 === e ? de : ue) + \"[^\\\\n]*(?:\\\\n(?!\\\\1\" + (1 === e ? ce : ae) + \" )[^\\\\n]*)*(\\\\n|$)\", \"gm\");\n}\nconst ge = me(1),\n  ye = me(2);\nfunction ke(e) {\n  const n = 1 === e ? ce : ae;\n  return new RegExp(\"^( *)(\" + n + \") [\\\\s\\\\S]+?(?:\\\\n{2,}(?! )(?!\\\\1\" + n + \" (?!\" + n + \" ))\\\\n*|\\\\s*\\\\n*$)\");\n}\nconst xe = ke(1),\n  ve = ke(2);\nfunction be(e, n) {\n  const t = 1 === n,\n    r = t ? xe : ve,\n    i = t ? ge : ye,\n    l = t ? fe : he;\n  return {\n    match(e, n, t) {\n      const i = oe.exec(t);\n      return i && (n.list || !n.inline && !n.simple) ? r.exec(e = i[1] + e) : null;\n    },\n    order: 1,\n    parse(e, n, r) {\n      const o = t ? +e[2] : void 0,\n        c = e[0].replace(d, \"\\n\").match(i);\n      let a = !1;\n      return {\n        items: c.map(function (e, t) {\n          const i = l.exec(e)[0].length,\n            o = new RegExp(\"^ {1,\" + i + \"}\", \"gm\"),\n            s = e.replace(o, \"\").replace(l, \"\"),\n            d = t === c.length - 1,\n            u = -1 !== s.indexOf(\"\\n\\n\") || d && a;\n          a = u;\n          const p = r.inline,\n            f = r.list;\n          let h;\n          r.list = !0, u ? (r.inline = !1, h = s.replace(le, \"\\n\\n\")) : (r.inline = !0, h = s.replace(le, \"\"));\n          const m = n(h, r);\n          return r.inline = p, r.list = f, m;\n        }),\n        ordered: t,\n        start: o\n      };\n    },\n    render: (n, t, r) => e(n.ordered ? \"ol\" : \"ul\", {\n      key: r.key,\n      start: \"20\" === n.type ? n.start : void 0\n    }, n.items.map(function (n, i) {\n      return e(\"li\", {\n        key: i\n      }, t(n, r));\n    }))\n  };\n}\nconst $e = new RegExp(\"^\\\\[((?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*)\\\\]\\\\(\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\\\\)\"),\n  Ee = /^!\\[(.*?)\\]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/,\n  we = [u, m, g, S, A, C, L, N, ge, xe, ye, ve],\n  Se = [...we, /^[^\\n]+(?:  \\n|\\n{2,})/, O, z];\nfunction Ce(e) {\n  return e.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, \"a\").replace(/[çÇ]/g, \"c\").replace(/[ðÐ]/g, \"d\").replace(/[ÈÉÊËéèêë]/g, \"e\").replace(/[ÏïÎîÍíÌì]/g, \"i\").replace(/[Ññ]/g, \"n\").replace(/[øØœŒÕõÔôÓóÒò]/g, \"o\").replace(/[ÜüÛûÚúÙù]/g, \"u\").replace(/[ŸÿÝý]/g, \"y\").replace(/[^a-z0-9- ]/gi, \"\").replace(/ /gi, \"-\").toLowerCase();\n}\nfunction Ae(e) {\n  return V.test(e) ? \"right\" : Z.test(e) ? \"center\" : q.test(e) ? \"left\" : null;\n}\nfunction Oe(e, n, t, r) {\n  const i = t.inTable;\n  t.inTable = !0;\n  let l = e.trim().split(/( *(?:`[^`]*`|<.*?>.*?<\\/.*?>(?!<\\/.*?>)|\\\\\\||\\|) *)/).reduce((e, i) => (\"|\" === i.trim() ? e.push(r ? {\n    type: \"26\"\n  } : {\n    type: \"27\",\n    text: i\n  }) : \"\" !== i && e.push.apply(e, n(i, t)), e), []);\n  t.inTable = i;\n  let o = [[]];\n  return l.forEach(function (e, n) {\n    \"26\" === e.type ? 0 !== n && n !== l.length - 1 && o.push([]) : (\"27\" !== e.type || null != l[n + 1] && \"26\" !== l[n + 1].type || (e.text = e.text.trimEnd()), o[o.length - 1].push(e));\n  }), o;\n}\nfunction Te(e, n, t) {\n  t.inline = !0;\n  const r = e[2] ? e[2].replace(G, \"\").split(\"|\").map(Ae) : [],\n    i = e[3] ? function (e, n, t) {\n      return e.trim().split(\"\\n\").map(function (e) {\n        return Oe(e, n, t, !0);\n      });\n    }(e[3], n, t) : [],\n    l = Oe(e[1], n, t, !!i.length);\n  return t.inline = !1, i.length ? {\n    align: r,\n    cells: i,\n    header: l,\n    type: \"25\"\n  } : {\n    children: l,\n    type: \"21\"\n  };\n}\nfunction Le(e, n) {\n  return null == e.align[n] ? {} : {\n    textAlign: e.align[n]\n  };\n}\nfunction Re(e) {\n  return function (n, t) {\n    return t.inline ? e.exec(n) : null;\n  };\n}\nfunction ze(e) {\n  return function (n, t) {\n    return t.inline || t.simple ? e.exec(n) : null;\n  };\n}\nfunction Me(e) {\n  return function (n, t) {\n    return t.inline || t.simple ? null : e.exec(n);\n  };\n}\nfunction Ie(e) {\n  return function (n) {\n    return e.exec(n);\n  };\n}\nfunction Ue(e, n, t) {\n  if (n.inline || n.simple) return null;\n  if (t && !t.endsWith(\"\\n\")) return null;\n  let r = \"\";\n  e.split(\"\\n\").every(e => !we.some(n => n.test(e)) && (r += e + \"\\n\", e.trim()));\n  const i = r.trimEnd();\n  return \"\" == i ? null : [r, i];\n}\nfunction je(e) {\n  try {\n    if (decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, \"\").match(/^\\s*(javascript|vbscript|data(?!:image)):/i)) return;\n  } catch (e) {\n    return null;\n  }\n  return e;\n}\nfunction Be(e) {\n  return e.replace(ie, \"$1\");\n}\nfunction Ne(e, n, t) {\n  const r = t.inline || !1,\n    i = t.simple || !1;\n  t.inline = !0, t.simple = !0;\n  const l = e(n, t);\n  return t.inline = r, t.simple = i, l;\n}\nfunction He(e, n, t) {\n  const r = t.inline || !1,\n    i = t.simple || !1;\n  t.inline = !1, t.simple = !0;\n  const l = e(n, t);\n  return t.inline = r, t.simple = i, l;\n}\nfunction De(e, n, t) {\n  const r = t.inline || !1;\n  t.inline = !1;\n  const i = e(n, t);\n  return t.inline = r, i;\n}\nconst Pe = (e, n, t) => ({\n  children: Ne(n, e[1], t)\n});\nfunction _e() {\n  return {};\n}\nfunction Fe() {\n  return null;\n}\nfunction We() {\n  for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n    e[_key] = arguments[_key];\n  }\n  return e.filter(Boolean).join(\" \");\n}\nfunction Ge(e, n, t) {\n  let r = e;\n  const i = n.split(\".\");\n  for (; i.length && (r = r[i[0]], void 0 !== r);) i.shift();\n  return r || t;\n}\nfunction Ze() {\n  let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  r.overrides = r.overrides || {}, r.slugify = r.slugify || Ce, r.namedCodesToUnicode = r.namedCodesToUnicode ? n({}, o, r.namedCodesToUnicode) : o;\n  const i = r.createElement || e.createElement;\n  function d(e, t) {\n    const o = Ge(r.overrides, `${e}.props`, {});\n    for (var _len2 = arguments.length, l = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      l[_key2 - 2] = arguments[_key2];\n    }\n    return i(function (e, n) {\n      const t = Ge(n, e);\n      return t ? \"function\" == typeof t || \"object\" == typeof t && \"render\" in t ? t : Ge(n, `${e}.component`, e) : e;\n    }(e, r.overrides), n({}, t, o, {\n      className: We(null == t ? void 0 : t.className, o.className) || void 0\n    }), ...l);\n  }\n  function G(n) {\n    n = n.replace(E, \"\");\n    let t = !1;\n    r.forceInline ? t = !0 : r.forceBlock || (t = !1 === F.test(n));\n    const i = le(ie(t ? n : `${n.trimEnd().replace(te, \"\")}\\n\\n`, {\n      inline: t\n    }));\n    for (; \"string\" == typeof i[i.length - 1] && !i[i.length - 1].trim();) i.pop();\n    if (null === r.wrapper) return i;\n    const l = r.wrapper || (t ? \"span\" : \"div\");\n    let o;\n    if (i.length > 1 || r.forceWrapper) o = i;else {\n      if (1 === i.length) return o = i[0], \"string\" == typeof o ? d(\"span\", {\n        key: \"outer\"\n      }, o) : o;\n      o = null;\n    }\n    return e.createElement(l, {\n      key: \"outer\"\n    }, o);\n  }\n  function Z(n) {\n    const t = n.match(a);\n    return t ? t.reduce(function (n, t, r) {\n      const i = t.indexOf(\"=\");\n      if (-1 !== i) {\n        const o = function (e) {\n            return -1 !== e.indexOf(\"-\") && null === e.match(R) && (e = e.replace(B, function (e, n) {\n              return n.toUpperCase();\n            })), e;\n          }(t.slice(0, i)).trim(),\n          c = function (e) {\n            const n = e[0];\n            return ('\"' === n || \"'\" === n) && e.length >= 2 && e[e.length - 1] === n ? e.slice(1, -1) : e;\n          }(t.slice(i + 1).trim()),\n          a = l[o] || o,\n          s = n[a] = function (e, n) {\n            return \"style\" === e ? n.split(/;\\s?/).reduce(function (e, n) {\n              const t = n.slice(0, n.indexOf(\":\"));\n              return e[t.trim().replace(/(-[a-z])/g, e => e[1].toUpperCase())] = n.slice(t.length + 1).trim(), e;\n            }, {}) : \"href\" === e || \"src\" === e ? je(n) : (n.match(M) && (n = n.slice(1, n.length - 1)), \"true\" === n || \"false\" !== n && n);\n          }(o, c);\n        \"string\" == typeof s && (O.test(s) || z.test(s)) && (n[a] = e.cloneElement(G(s.trim()), {\n          key: r\n        }));\n      } else \"style\" !== t && (n[l[t] || t] = !0);\n      return n;\n    }, {}) : null;\n  }\n  const q = [],\n    V = {},\n    X = {\n      0: {\n        match: Me(u),\n        order: 1,\n        parse: (e, n, t) => ({\n          children: n(e[0].replace(p, \"\"), t)\n        }),\n        render: (e, n, t) => d(\"blockquote\", {\n          key: t.key\n        }, n(e.children, t))\n      },\n      1: {\n        match: Ie(f),\n        order: 1,\n        parse: _e,\n        render: (e, n, t) => d(\"br\", {\n          key: t.key\n        })\n      },\n      2: {\n        match: Me(h),\n        order: 1,\n        parse: _e,\n        render: (e, n, t) => d(\"hr\", {\n          key: t.key\n        })\n      },\n      3: {\n        match: Me(g),\n        order: 0,\n        parse: e => ({\n          lang: void 0,\n          text: e[0].replace(/^ {4}/gm, \"\").replace(/\\n+$/, \"\")\n        }),\n        render: (e, t, r) => d(\"pre\", {\n          key: r.key\n        }, d(\"code\", n({}, e.attrs, {\n          className: e.lang ? `lang-${e.lang}` : \"\"\n        }), e.text))\n      },\n      4: {\n        match: Me(m),\n        order: 0,\n        parse: e => ({\n          attrs: Z(e[3] || \"\"),\n          lang: e[2] || void 0,\n          text: e[4],\n          type: \"3\"\n        })\n      },\n      5: {\n        match: ze(y),\n        order: 3,\n        parse: e => ({\n          text: e[2]\n        }),\n        render: (e, n, t) => d(\"code\", {\n          key: t.key\n        }, e.text)\n      },\n      6: {\n        match: Me(v),\n        order: 0,\n        parse: e => (q.push({\n          footnote: e[2],\n          identifier: e[1]\n        }), {}),\n        render: Fe\n      },\n      7: {\n        match: Re(b),\n        order: 1,\n        parse: e => ({\n          target: `#${r.slugify(e[1])}`,\n          text: e[1]\n        }),\n        render: (e, n, t) => d(\"a\", {\n          key: t.key,\n          href: je(e.target)\n        }, d(\"sup\", {\n          key: t.key\n        }, e.text))\n      },\n      8: {\n        match: Re(w),\n        order: 1,\n        parse: e => ({\n          completed: \"x\" === e[1].toLowerCase()\n        }),\n        render: (e, n, t) => d(\"input\", {\n          checked: e.completed,\n          key: t.key,\n          readOnly: !0,\n          type: \"checkbox\"\n        })\n      },\n      9: {\n        match: Me(r.enforceAtxHeadings ? C : S),\n        order: 1,\n        parse: (e, n, t) => ({\n          children: Ne(n, e[2], t),\n          id: r.slugify(e[2]),\n          level: e[1].length\n        }),\n        render: (e, n, t) => d(`h${e.level}`, {\n          id: e.id,\n          key: t.key\n        }, n(e.children, t))\n      },\n      10: {\n        match: Me(A),\n        order: 0,\n        parse: (e, n, t) => ({\n          children: Ne(n, e[1], t),\n          level: \"=\" === e[2] ? 1 : 2,\n          type: \"9\"\n        })\n      },\n      11: {\n        match: Ie(O),\n        order: 1,\n        parse(e, n, t) {\n          const [, r] = e[3].match(re),\n            i = new RegExp(`^${r}`, \"gm\"),\n            l = e[3].replace(i, \"\"),\n            o = (a = l, Se.some(e => e.test(a)) ? De : Ne);\n          var a;\n          const s = e[1].toLowerCase(),\n            d = -1 !== c.indexOf(s),\n            u = {\n              attrs: Z(e[2]),\n              noInnerParse: d,\n              tag: (d ? s : e[1]).trim()\n            };\n          return t.inAnchor = t.inAnchor || \"a\" === s, d ? u.text = e[3] : u.children = o(n, l, t), t.inAnchor = !1, u;\n        },\n        render: (e, t, r) => d(e.tag, n({\n          key: r.key\n        }, e.attrs), e.text || t(e.children, r))\n      },\n      13: {\n        match: Ie(z),\n        order: 1,\n        parse: e => ({\n          attrs: Z(e[2] || \"\"),\n          tag: e[1].trim()\n        }),\n        render: (e, t, r) => d(e.tag, n({}, e.attrs, {\n          key: r.key\n        }))\n      },\n      12: {\n        match: Ie(L),\n        order: 1,\n        parse: () => ({}),\n        render: Fe\n      },\n      14: {\n        match: ze(Ee),\n        order: 1,\n        parse: e => ({\n          alt: e[1],\n          target: Be(e[2]),\n          title: e[3]\n        }),\n        render: (e, n, t) => d(\"img\", {\n          key: t.key,\n          alt: e.alt || void 0,\n          title: e.title || void 0,\n          src: je(e.target)\n        })\n      },\n      15: {\n        match: Re($e),\n        order: 3,\n        parse: (e, n, t) => ({\n          children: He(n, e[1], t),\n          target: Be(e[2]),\n          title: e[3]\n        }),\n        render: (e, n, t) => d(\"a\", {\n          key: t.key,\n          href: je(e.target),\n          title: e.title\n        }, n(e.children, t))\n      },\n      16: {\n        match: Re(j),\n        order: 0,\n        parse: e => ({\n          children: [{\n            text: e[1],\n            type: \"27\"\n          }],\n          target: e[1],\n          type: \"15\"\n        })\n      },\n      17: {\n        match: (e, n) => n.inAnchor ? null : Re(I)(e, n),\n        order: 0,\n        parse: e => ({\n          children: [{\n            text: e[1],\n            type: \"27\"\n          }],\n          target: e[1],\n          title: void 0,\n          type: \"15\"\n        })\n      },\n      18: {\n        match: Re(U),\n        order: 0,\n        parse(e) {\n          let n = e[1],\n            t = e[1];\n          return s.test(t) || (t = \"mailto:\" + t), {\n            children: [{\n              text: n.replace(\"mailto:\", \"\"),\n              type: \"27\"\n            }],\n            target: t,\n            type: \"15\"\n          };\n        }\n      },\n      20: be(d, 1),\n      33: be(d, 2),\n      19: {\n        match: Me(k),\n        order: 3,\n        parse: _e,\n        render: () => \"\\n\"\n      },\n      21: {\n        match: Ue,\n        order: 3,\n        parse: Pe,\n        render: (e, n, t) => d(\"p\", {\n          key: t.key\n        }, n(e.children, t))\n      },\n      22: {\n        match: Re(H),\n        order: 0,\n        parse: e => (V[e[1]] = {\n          target: e[2],\n          title: e[4]\n        }, {}),\n        render: Fe\n      },\n      23: {\n        match: ze(D),\n        order: 0,\n        parse: e => ({\n          alt: e[1] || void 0,\n          ref: e[2]\n        }),\n        render: (e, n, t) => V[e.ref] ? d(\"img\", {\n          key: t.key,\n          alt: e.alt,\n          src: je(V[e.ref].target),\n          title: V[e.ref].title\n        }) : null\n      },\n      24: {\n        match: Re(P),\n        order: 0,\n        parse: (e, n, t) => ({\n          children: n(e[1], t),\n          fallbackChildren: n(e[0].replace(_, \"\\\\$1\"), t),\n          ref: e[2]\n        }),\n        render: (e, n, t) => V[e.ref] ? d(\"a\", {\n          key: t.key,\n          href: je(V[e.ref].target),\n          title: V[e.ref].title\n        }, n(e.children, t)) : d(\"span\", {\n          key: t.key\n        }, n(e.fallbackChildren, t))\n      },\n      25: {\n        match: Me(N),\n        order: 1,\n        parse: Te,\n        render(e, n, t) {\n          const r = e;\n          return d(\"table\", {\n            key: t.key\n          }, d(\"thead\", null, d(\"tr\", null, r.header.map(function (e, i) {\n            return d(\"th\", {\n              key: i,\n              style: Le(r, i)\n            }, n(e, t));\n          }))), d(\"tbody\", null, r.cells.map(function (e, i) {\n            return d(\"tr\", {\n              key: i\n            }, e.map(function (e, i) {\n              return d(\"td\", {\n                key: i,\n                style: Le(r, i)\n              }, n(e, t));\n            }));\n          })));\n        }\n      },\n      27: {\n        match: Ie(ne),\n        order: 4,\n        parse: e => ({\n          text: e[0].replace(T, (e, n) => r.namedCodesToUnicode[n] ? r.namedCodesToUnicode[n] : e)\n        }),\n        render: e => e.text\n      },\n      28: {\n        match: ze(Q),\n        order: 2,\n        parse: (e, n, t) => ({\n          children: n(e[2], t)\n        }),\n        render: (e, n, t) => d(\"strong\", {\n          key: t.key\n        }, n(e.children, t))\n      },\n      29: {\n        match: ze(J),\n        order: 3,\n        parse: (e, n, t) => ({\n          children: n(e[2], t)\n        }),\n        render: (e, n, t) => d(\"em\", {\n          key: t.key\n        }, n(e.children, t))\n      },\n      30: {\n        match: ze(ee),\n        order: 1,\n        parse: e => ({\n          text: e[1],\n          type: \"27\"\n        })\n      },\n      31: {\n        match: ze(K),\n        order: 3,\n        parse: Pe,\n        render: (e, n, t) => d(\"mark\", {\n          key: t.key\n        }, n(e.children, t))\n      },\n      32: {\n        match: ze(Y),\n        order: 3,\n        parse: Pe,\n        render: (e, n, t) => d(\"del\", {\n          key: t.key\n        }, n(e.children, t))\n      }\n    };\n  !0 === r.disableParsingRawHTML && (delete X[11], delete X[13]);\n  const ie = function (e) {\n      let n = Object.keys(e);\n      function t(r, i) {\n        let l = [],\n          o = \"\";\n        for (; r;) {\n          let c = 0;\n          for (; c < n.length;) {\n            const a = n[c],\n              s = e[a],\n              d = s.match(r, i, o);\n            if (d) {\n              const e = d[0];\n              r = r.substring(e.length);\n              const n = s.parse(d, t, i);\n              null == n.type && (n.type = a), l.push(n), o = e;\n              break;\n            }\n            c++;\n          }\n        }\n        return l;\n      }\n      return n.sort(function (n, t) {\n        let r = e[n].order,\n          i = e[t].order;\n        return r !== i ? r - i : n < t ? -1 : 1;\n      }), function (e, n) {\n        return t(function (e) {\n          return e.replace(x, \"\\n\").replace($, \"\").replace(W, \"    \");\n        }(e), n);\n      };\n    }(X),\n    le = (oe = function (e, n) {\n      return function (t, r, i) {\n        const l = e[t.type].render;\n        return n ? n(() => l(t, r, i), t, r, i) : l(t, r, i);\n      };\n    }(X, r.renderRule), function e(n) {\n      let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (Array.isArray(n)) {\n        const r = t.key,\n          i = [];\n        let l = !1;\n        for (let r = 0; r < n.length; r++) {\n          t.key = r;\n          const o = e(n[r], t),\n            c = \"string\" == typeof o;\n          c && l ? i[i.length - 1] += o : null !== o && i.push(o), l = c;\n        }\n        return t.key = r, i;\n      }\n      return oe(n, e, t);\n    });\n  var oe;\n  const ce = G(t);\n  return q.length ? d(\"div\", null, ce, d(\"footer\", {\n    key: \"footer\"\n  }, q.map(function (e) {\n    return d(\"div\", {\n      id: r.slugify(e.identifier),\n      key: e.identifier\n    }, e.identifier, le(ie(e.footnote, {\n      inline: !0\n    })));\n  }))) : ce;\n}\nexport default n => {\n  let {\n      children: r = \"\",\n      options: i\n    } = n,\n    l = function (e, n) {\n      if (null == e) return {};\n      var t,\n        r,\n        i = {},\n        l = Object.keys(e);\n      for (r = 0; r < l.length; r++) n.indexOf(t = l[r]) >= 0 || (i[t] = e[t]);\n      return i;\n    }(n, t);\n  return e.cloneElement(Ze(r, i), l);\n};\nexport { r as RuleType, Ze as compiler, Ce as slugify };\n//# sourceMappingURL=index.modern.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}